"""
Vulnerability Scan Job for FedRAMP RA-5 Compliance

Scheduled job for weekly vulnerability scans:
- Automated weekly scans
- Notification generation
- POA&M generation for open vulnerabilities

This job should be run weekly via cron or scheduler.

FedRAMP RA-5: Vulnerability scanning and tracking.
"""

import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional
from sqlalchemy.orm import Session
from sqlalchemy import and_

from core.database import SessionLocal
from services.security.vulnerability_scanner import VulnerabilityScanner
from models.vulnerability import (
    Vulnerability,
    VulnerabilityScan,
    RemediationStatus,
    VulnerabilitySeverity,
)
from utils.logger import logger

logging.basicConfig(level=logging.INFO)


def run_vulnerability_scan() -> Dict:
    """
    Main job function to perform vulnerability scan.
    This function can be called directly or via cron endpoint.
    
    Returns:
        Dict with execution results
    """
    db: Session = SessionLocal()
    
    try:
        logger.info("Starting scheduled vulnerability scan job")
        
        scanner = VulnerabilityScanner(db)
        
        # Perform scan
        scan = scanner.scan_all_components(
            scan_type="scheduled",
            scan_depth="full"
        )
        
        # Generate notifications if needed
        notifications = generate_notifications(db, scan)
        
        # Generate POA&M for critical/high vulnerabilities
        poam_items = generate_poam_items(db, scan)
        
        logger.info(
            "Vulnerability scan job completed",
            extra={
                "scan_id": scan.id,
                "vulnerabilities_found": scan.vulnerabilities_found,
                "notifications_sent": len(notifications),
                "poam_items_generated": len(poam_items),
                "event_type": "job.vulnerability_scan.completed",
            }
        )
        
        return {
            "status": "success",
            "timestamp": datetime.utcnow().isoformat(),
            "scan_id": scan.id,
            "vulnerabilities_found": scan.vulnerabilities_found,
            "vulnerabilities_critical": scan.vulnerabilities_critical,
            "vulnerabilities_high": scan.vulnerabilities_high,
            "notifications": notifications,
            "poam_items": poam_items,
        }
        
    except Exception as e:
        logger.error(f"Vulnerability scan job failed: {e}", exc_info=True)
        return {
            "status": "error",
            "timestamp": datetime.utcnow().isoformat(),
            "error": str(e),
        }
    finally:
        db.close()


def generate_notifications(db: Session, scan: VulnerabilityScan) -> List[Dict]:
    """
    Generate notifications for new or critical vulnerabilities.
    
    Args:
        db: Database session
        scan: Vulnerability scan record
        
    Returns:
        List of notification dictionaries
    """
    notifications = []
    
    try:
        # Find new critical/high vulnerabilities from this scan
        new_critical = db.query(Vulnerability).filter(
            Vulnerability.scan_id == scan.id,
            Vulnerability.severity.in_([
                VulnerabilitySeverity.CRITICAL.value,
                VulnerabilitySeverity.HIGH.value
            ]),
            Vulnerability.remediation_status == RemediationStatus.OPEN.value,
        ).all()
        
        if new_critical:
            notification = {
                "type": "vulnerability_alert",
                "severity": "high",
                "title": f"New Critical/High Vulnerabilities Detected",
                "message": (
                    f"Vulnerability scan found {len(new_critical)} new critical or high severity "
                    f"vulnerabilities. Please review and remediate."
                ),
                "vulnerability_count": len(new_critical),
                "scan_id": scan.id,
                "timestamp": datetime.utcnow().isoformat(),
            }
            notifications.append(notification)
            
            logger.info(
                f"Generated notification for {len(new_critical)} critical/high vulnerabilities",
                extra={
                    "scan_id": scan.id,
                    "vulnerability_count": len(new_critical),
                    "event_type": "vulnerability.notification.generated",
                }
            )
        
        # Check for vulnerabilities that have been open for > 30 days
        thirty_days_ago = datetime.utcnow() - timedelta(days=30)
        stale_vulnerabilities = db.query(Vulnerability).filter(
            Vulnerability.remediation_status == RemediationStatus.OPEN.value,
            Vulnerability.first_detected_at <= thirty_days_ago,
            Vulnerability.severity.in_([
                VulnerabilitySeverity.CRITICAL.value,
                VulnerabilitySeverity.HIGH.value
            ]),
        ).count()
        
        if stale_vulnerabilities > 0:
            notification = {
                "type": "vulnerability_stale_alert",
                "severity": "medium",
                "title": f"Stale Vulnerabilities Requiring Attention",
                "message": (
                    f"{stale_vulnerabilities} critical or high severity vulnerabilities have been "
                    f"open for more than 30 days. Please update remediation status."
                ),
                "vulnerability_count": stale_vulnerabilities,
                "timestamp": datetime.utcnow().isoformat(),
            }
            notifications.append(notification)
        
    except Exception as e:
        logger.error(f"Failed to generate notifications: {e}", exc_info=True)
    
    return notifications


def generate_poam_items(db: Session, scan: VulnerabilityScan) -> List[Dict]:
    """
    Generate POA&M (Plan of Action and Milestones) items for open vulnerabilities.
    
    Args:
        db: Database session
        scan: Vulnerability scan record
        
    Returns:
        List of POA&M item dictionaries
    """
    poam_items = []
    
    try:
        # Get open critical and high vulnerabilities
        open_vulnerabilities = db.query(Vulnerability).filter(
            Vulnerability.remediation_status == RemediationStatus.OPEN.value,
            Vulnerability.severity.in_([
                VulnerabilitySeverity.CRITICAL.value,
                VulnerabilitySeverity.HIGH.value
            ]),
            Vulnerability.is_active == True,
        ).all()
        
        for vuln in open_vulnerabilities:
            # Calculate due date (30 days for critical, 60 days for high)
            days_to_remediate = 30 if vuln.severity == VulnerabilitySeverity.CRITICAL.value else 60
            due_date = vuln.first_detected_at + timedelta(days=days_to_remediate)
            
            poam_item = {
                "poam_id": f"VULN-{vuln.id}-{datetime.utcnow().strftime('%Y%m%d')}",
                "vulnerability_id": vuln.id,
                "cve_id": vuln.cve_id,
                "severity": vuln.severity,
                "component_name": vuln.component_name,
                "component_version": vuln.component_version,
                "description": vuln.cve_description or f"Vulnerability in {vuln.component_name}",
                "due_date": due_date.isoformat(),
                "status": "open",
                "remediation_action": (
                    f"Update {vuln.component_name} to a patched version that addresses {vuln.cve_id}"
                ),
                "created_at": datetime.utcnow().isoformat(),
            }
            
            # Update vulnerability with POA&M ID
            if not vuln.poam_id:
                vuln.poam_id = poam_item["poam_id"]
                vuln.poam_due_date = due_date
                vuln.poam_status = "open"
                db.commit()
            
            poam_items.append(poam_item)
        
        logger.info(
            f"Generated {len(poam_items)} POA&M items",
            extra={
                "scan_id": scan.id,
                "poam_count": len(poam_items),
                "event_type": "vulnerability.poam.generated",
            }
        )
        
    except Exception as e:
        logger.error(f"Failed to generate POA&M items: {e}", exc_info=True)
    
    return poam_items


def get_scan_summary(scan_id: int) -> Optional[Dict]:
    """
    Get summary of a vulnerability scan.
    
    Args:
        scan_id: Scan ID
        
    Returns:
        Dictionary with scan summary or None
    """
    db: Session = SessionLocal()
    
    try:
        scan = db.query(VulnerabilityScan).filter(VulnerabilityScan.id == scan_id).first()
        
        if not scan:
            return None
        
        return {
            "scan_id": scan.id,
            "scan_type": scan.scan_type,
            "scan_status": scan.scan_status,
            "vulnerabilities_found": scan.vulnerabilities_found,
            "vulnerabilities_critical": scan.vulnerabilities_critical,
            "vulnerabilities_high": scan.vulnerabilities_high,
            "vulnerabilities_medium": scan.vulnerabilities_medium,
            "vulnerabilities_low": scan.vulnerabilities_low,
            "started_at": scan.started_at.isoformat() if scan.started_at else None,
            "completed_at": scan.completed_at.isoformat() if scan.completed_at else None,
            "duration_seconds": scan.duration_seconds,
            "scan_summary": scan.scan_summary,
        }
        
    finally:
        db.close()


def generate_compliance_report() -> Dict:
    """
    Generate FedRAMP RA-5 compliance report.
    
    Returns:
        Dictionary with compliance report data
    """
    db: Session = SessionLocal()
    
    try:
        scanner = VulnerabilityScanner(db)
        report = scanner.generate_compliance_report()
        
        return {
            "status": "success",
            "timestamp": datetime.utcnow().isoformat(),
            "report": report,
        }
        
    except Exception as e:
        logger.error(f"Compliance report generation failed: {e}", exc_info=True)
        return {
            "status": "error",
            "timestamp": datetime.utcnow().isoformat(),
            "error": str(e),
        }
    finally:
        db.close()


if __name__ == "__main__":
    # Allow running directly for testing
    result = run_vulnerability_scan()
    print(f"Job result: {result}")
