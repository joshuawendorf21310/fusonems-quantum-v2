"""
Vulnerability Router for FedRAMP RA-5 Compliance

API endpoints for:
- Listing vulnerabilities
- Updating remediation status
- Generating compliance reports
- Exporting vulnerability data
- Managing vulnerability scans

FedRAMP RA-5: Vulnerability scanning and tracking.
"""

from datetime import datetime
from typing import List, Optional
from enum import Enum

from fastapi import APIRouter, Depends, HTTPException, Query, Request
from pydantic import BaseModel, Field
from sqlalchemy.orm import Session

from core.database import get_db
from core.security import require_roles, get_current_user
from models.user import User, UserRole
from models.vulnerability import (
    Vulnerability,
    VulnerabilityScan,
    VulnerabilityRemediation,
    VulnerabilitySeverity,
    RemediationStatus,
    ComponentType,
)
from services.security.vulnerability_scanner import VulnerabilityScanner
from utils.logger import logger


router = APIRouter(
    prefix="/api/v1/security/vulnerabilities",
    tags=["Vulnerability Management"],
)


# ============================================================================
# Request/Response Models
# ============================================================================


class VulnerabilityResponse(BaseModel):
    """Vulnerability response model"""
    id: int
    cve_id: str
    severity: str
    base_score: Optional[float]
    component_type: str
    component_name: str
    component_version: Optional[str]
    remediation_status: str
    remediation_notes: Optional[str]
    remediation_date: Optional[datetime]
    cve_published_date: Optional[datetime]
    first_detected_at: datetime
    last_scanned_at: Optional[datetime]
    
    class Config:
        from_attributes = True


class VulnerabilityListResponse(BaseModel):
    """Paginated vulnerability list response"""
    vulnerabilities: List[VulnerabilityResponse]
    total: int
    limit: int
    offset: int


class RemediationUpdateRequest(BaseModel):
    """Request to update remediation status"""
    status: RemediationStatus
    notes: Optional[str] = None
    remediation_version: Optional[str] = None


class ScanRequest(BaseModel):
    """Request to start a vulnerability scan"""
    scan_type: str = "ad_hoc"
    scan_depth: str = "full"


class ScanResponse(BaseModel):
    """Vulnerability scan response"""
    id: int
    scan_type: str
    scan_status: str
    vulnerabilities_found: int
    vulnerabilities_critical: int
    vulnerabilities_high: int
    vulnerabilities_medium: int
    vulnerabilities_low: int
    started_at: datetime
    completed_at: Optional[datetime]
    duration_seconds: Optional[int]
    scan_summary: Optional[str]
    
    class Config:
        from_attributes = True


class ComplianceReportResponse(BaseModel):
    """Compliance report response"""
    report_date: str
    total_vulnerabilities: int
    by_severity: dict
    by_remediation_status: dict
    recent_scans: List[dict]
    compliance_status: str


class VulnerabilityExportRequest(BaseModel):
    """Request to export vulnerability data"""
    format: str = "json"  # "json", "csv"
    severity: Optional[str] = None
    remediation_status: Optional[str] = None
    component_type: Optional[str] = None


# ============================================================================
# Endpoints
# ============================================================================


@router.get("/", response_model=VulnerabilityListResponse)
async def list_vulnerabilities(
    severity: Optional[str] = Query(None, description="Filter by severity"),
    remediation_status: Optional[str] = Query(None, description="Filter by remediation status"),
    component_type: Optional[str] = Query(None, description="Filter by component type"),
    limit: int = Query(100, ge=1, le=1000, description="Maximum number of results"),
    offset: int = Query(0, ge=0, description="Offset for pagination"),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    List vulnerabilities with optional filters.
    
    Requires: SECURITY_ADMIN or ADMIN role
    """
    require_roles([UserRole.SECURITY_ADMIN, UserRole.ADMIN])(current_user)
    
    scanner = VulnerabilityScanner(db)
    vulnerabilities, total = scanner.list_vulnerabilities(
        severity=severity,
        remediation_status=remediation_status,
        component_type=component_type,
        limit=limit,
        offset=offset
    )
    
    return VulnerabilityListResponse(
        vulnerabilities=[VulnerabilityResponse.from_orm(v) for v in vulnerabilities],
        total=total,
        limit=limit,
        offset=offset
    )


@router.get("/{vulnerability_id}", response_model=VulnerabilityResponse)
async def get_vulnerability(
    vulnerability_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    Get vulnerability details by ID.
    
    Requires: SECURITY_ADMIN or ADMIN role
    """
    require_roles([UserRole.SECURITY_ADMIN, UserRole.ADMIN])(current_user)
    
    scanner = VulnerabilityScanner(db)
    vulnerability = scanner.get_vulnerability(vulnerability_id)
    
    if not vulnerability:
        raise HTTPException(status_code=404, detail="Vulnerability not found")
    
    return VulnerabilityResponse.from_orm(vulnerability)


@router.patch("/{vulnerability_id}/remediation", response_model=VulnerabilityResponse)
async def update_remediation_status(
    vulnerability_id: int,
    request: RemediationUpdateRequest,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    Update remediation status for a vulnerability.
    
    Requires: SECURITY_ADMIN or ADMIN role
    """
    require_roles([UserRole.SECURITY_ADMIN, UserRole.ADMIN])(current_user)
    
    scanner = VulnerabilityScanner(db)
    vulnerability = scanner.update_remediation_status(
        vulnerability_id=vulnerability_id,
        status=request.status,
        notes=request.notes,
        remediation_version=request.remediation_version
    )
    
    if not vulnerability:
        raise HTTPException(status_code=404, detail="Vulnerability not found")
    
    logger.info(
        f"Vulnerability remediation status updated",
        extra={
            "vulnerability_id": vulnerability_id,
            "status": request.status.value,
            "user_id": current_user.id,
            "event_type": "vulnerability.remediation.updated",
        }
    )
    
    return VulnerabilityResponse.from_orm(vulnerability)


@router.post("/scans", response_model=ScanResponse)
async def start_scan(
    request: ScanRequest,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    Start a vulnerability scan.
    
    Requires: SECURITY_ADMIN or ADMIN role
    """
    require_roles([UserRole.SECURITY_ADMIN, UserRole.ADMIN])(current_user)
    
    scanner = VulnerabilityScanner(db)
    
    try:
        scan = scanner.scan_all_components(
            scan_type=request.scan_type,
            scan_depth=request.scan_depth
        )
        
        logger.info(
            f"Vulnerability scan started",
            extra={
                "scan_id": scan.id,
                "scan_type": request.scan_type,
                "user_id": current_user.id,
                "event_type": "vulnerability.scan.started",
            }
        )
        
        return ScanResponse.from_orm(scan)
        
    except Exception as e:
        logger.error(f"Failed to start vulnerability scan: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Scan failed: {str(e)}")


@router.get("/scans/{scan_id}", response_model=ScanResponse)
async def get_scan(
    scan_id: int,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    Get vulnerability scan details by ID.
    
    Requires: SECURITY_ADMIN or ADMIN role
    """
    require_roles([UserRole.SECURITY_ADMIN, UserRole.ADMIN])(current_user)
    
    scan = db.query(VulnerabilityScan).filter(VulnerabilityScan.id == scan_id).first()
    
    if not scan:
        raise HTTPException(status_code=404, detail="Scan not found")
    
    return ScanResponse.from_orm(scan)


@router.get("/scans", response_model=List[ScanResponse])
async def list_scans(
    limit: int = Query(50, ge=1, le=100, description="Maximum number of results"),
    offset: int = Query(0, ge=0, description="Offset for pagination"),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    List vulnerability scans.
    
    Requires: SECURITY_ADMIN or ADMIN role
    """
    require_roles([UserRole.SECURITY_ADMIN, UserRole.ADMIN])(current_user)
    
    scans = db.query(VulnerabilityScan).order_by(
        VulnerabilityScan.created_at.desc()
    ).offset(offset).limit(limit).all()
    
    return [ScanResponse.from_orm(scan) for scan in scans]


@router.get("/reports/compliance", response_model=ComplianceReportResponse)
async def get_compliance_report(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    Generate FedRAMP RA-5 compliance report.
    
    Requires: SECURITY_ADMIN or ADMIN role
    """
    require_roles([UserRole.SECURITY_ADMIN, UserRole.ADMIN])(current_user)
    
    scanner = VulnerabilityScanner(db)
    report = scanner.generate_compliance_report()
    
    return ComplianceReportResponse(**report)


@router.post("/export")
async def export_vulnerabilities(
    request: VulnerabilityExportRequest,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    Export vulnerability data in various formats.
    
    Requires: SECURITY_ADMIN or ADMIN role
    """
    require_roles([UserRole.SECURITY_ADMIN, UserRole.ADMIN])(current_user)
    
    scanner = VulnerabilityScanner(db)
    vulnerabilities, _ = scanner.list_vulnerabilities(
        severity=request.severity,
        remediation_status=request.remediation_status,
        component_type=request.component_type,
        limit=10000  # Large limit for export
    )
    
    if request.format == "json":
        from fastapi.responses import JSONResponse
        return JSONResponse(
            content={
                "export_date": datetime.utcnow().isoformat(),
                "vulnerabilities": [
                    {
                        "cve_id": v.cve_id,
                        "severity": v.severity,
                        "base_score": v.base_score,
                        "component_type": v.component_type,
                        "component_name": v.component_name,
                        "component_version": v.component_version,
                        "remediation_status": v.remediation_status,
                        "cve_published_date": v.cve_published_date.isoformat() if v.cve_published_date else None,
                        "first_detected_at": v.first_detected_at.isoformat(),
                    }
                    for v in vulnerabilities
                ]
            }
        )
    
    elif request.format == "csv":
        import csv
        from fastapi.responses import StreamingResponse
        from io import StringIO
        
        output = StringIO()
        writer = csv.writer(output)
        
        # Write header
        writer.writerow([
            "CVE ID",
            "Severity",
            "Base Score",
            "Component Type",
            "Component Name",
            "Component Version",
            "Remediation Status",
            "Published Date",
            "First Detected",
        ])
        
        # Write data
        for v in vulnerabilities:
            writer.writerow([
                v.cve_id,
                v.severity,
                v.base_score or "",
                v.component_type,
                v.component_name,
                v.component_version or "",
                v.remediation_status,
                v.cve_published_date.isoformat() if v.cve_published_date else "",
                v.first_detected_at.isoformat(),
            ])
        
        output.seek(0)
        return StreamingResponse(
            iter([output.getvalue()]),
            media_type="text/csv",
            headers={
                "Content-Disposition": f"attachment; filename=vulnerabilities_{datetime.utcnow().strftime('%Y%m%d')}.csv"
            }
        )
    
    else:
        raise HTTPException(status_code=400, detail=f"Unsupported export format: {request.format}")


@router.get("/statistics/summary")
async def get_statistics_summary(
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user),
):
    """
    Get vulnerability statistics summary.
    
    Requires: SECURITY_ADMIN or ADMIN role
    """
    require_roles([UserRole.SECURITY_ADMIN, UserRole.ADMIN])(current_user)
    
    # Total vulnerabilities
    total = db.query(Vulnerability).filter(Vulnerability.is_active == True).count()
    
    # By severity
    by_severity = {}
    for severity in VulnerabilitySeverity:
        count = db.query(Vulnerability).filter(
            Vulnerability.is_active == True,
            Vulnerability.severity == severity.value
        ).count()
        by_severity[severity.value] = count
    
    # By remediation status
    by_status = {}
    for status in RemediationStatus:
        count = db.query(Vulnerability).filter(
            Vulnerability.is_active == True,
            Vulnerability.remediation_status == status.value
        ).count()
        by_status[status.value] = count
    
    # By component type
    by_component = {}
    for component_type in ComponentType:
        count = db.query(Vulnerability).filter(
            Vulnerability.is_active == True,
            Vulnerability.component_type == component_type.value
        ).count()
        by_component[component_type.value] = count
    
    # Recent scans
    recent_scans = db.query(VulnerabilityScan).order_by(
        VulnerabilityScan.created_at.desc()
    ).limit(5).all()
    
    return {
        "total_vulnerabilities": total,
        "by_severity": by_severity,
        "by_remediation_status": by_status,
        "by_component_type": by_component,
        "recent_scans": [
            {
                "id": scan.id,
                "type": scan.scan_type,
                "status": scan.scan_status,
                "vulnerabilities_found": scan.vulnerabilities_found,
                "started_at": scan.started_at.isoformat() if scan.started_at else None,
            }
            for scan in recent_scans
        ],
    }
